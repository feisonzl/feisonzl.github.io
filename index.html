<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>feison&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="feison's blog">
<meta property="og:url" content="https://feisonzl.github.io/index.html">
<meta property="og:site_name" content="feison's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="feison's blog">
  
    <link rel="alternative" href="/atom.xml" title="feison&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">feison</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:123@123.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="#" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">feison</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img lazy-src="/img/avatar.png" class="js-avatar">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">feison</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:123@123.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="#" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-原-中断处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/29/原-中断处理/" class="article-date">
      <time datetime="2016-09-29T21:30:10.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/原-中断处理/">[原]中断处理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="1-注册中断处理例程"><a href="#1-注册中断处理例程" class="headerlink" title="1 注册中断处理例程"></a>1 注册中断处理例程</h3><p>许多设备的内部工作通常是在和处理器完全不同的时间周期里完成的，并且总要比处理器慢，为了不让cpu一直等待外部设备的时间处理，必须引入中断概念。中断，当设备处理完内部工作后需要获取cpu资源时，向cpu发出的信号。该信号的发送依赖于中断信号线，不同的设备需要不同的中断信号线（当然也会有共享中断信号）。内核维护了一个中断信号线的注册表，驱动程序在使用中断前要请求一个中断通道（或IRQ中断请求），在使用结束后释放该通道。下面是请求和释放中断通道的相应接口：</p>
<pre><code>#include &amp;lt;linux/sched.h&amp;gt;
int request_irq(unsigned int irq,
                irqreturn_t (*handler)(int, void *, struct pt_regs *),
                unsigned long flags,
                const char *dev_name,
                void *dev_id);
参数：
unsigned int irq：
请求的中断号

irqreturn_t (*handler)：
安装的处理函数指针. 我们在本章后面讨论给这个函数的参数以及它的返回值.

unsigned long flags：
如你会希望的, 一个与中断管理相关的选项的位掩码(后面描述).

const char *dev_name：
这个传递给 request_irq 的字串用在 /proc/interrupts 来显示中断的拥有者(下一节看到)

void *dev_id：
用作共享中断线的指针. 它是一个独特的标识, 用在当释放中断线时以及可能还被驱动用来指向它自己的私有数据区(来标识哪个设备在中断). 如果中断没有被共享, dev_id 可以设置为 NULL, 但是使用这个项指向设备结构不管如何是个好主意. 我们将在&quot;实现一个处理&quot;一节中看到 dev_id 的一个实际应用.

flags 中可以设置的位如下:
SA_INTERRUPT
当置位了, 这表示一个&quot;快速&quot;中断处理. 快速处理在当前处理器上禁止中断来执行(这个主题在&quot;快速和慢速处理&quot;一节涉及).
SA_SHIRQ
这个位表示中断可以在设备间共享. 共享的概念在&quot;中断共享&quot;一节中略述.
SA_SAMPLE_RANDOM
这个位表示产生的中断能够有贡献给 /dev/random 和 /dev/urandom 使用的加密池. 这些设备在读取时返回真正的随机数并且设计来帮助应用程序软件为加密选择安全钥. 这样的随机数从一个由各种随机事件贡献的加密池中提取的. 如果你的设备以真正随机的时间产生中断, 你应当设置这个标志. 如果, 另一方面, 你的中断是可预测的( 例如, 一个帧抓取器的场消隐), 这个标志不值得设置 -- 它无论如何不会对系统加密有贡献. 可能被攻击者影响的设备不应当设置这个标志; 例如, 网络驱动易遭受从外部计时的可预测报文并且不应当对加密池有贡献. 更多信息看 drivers/char/random.c 的注释。
返回值：
0:成功
负数：错误码

void free_irq(unsigned int irq, void *dev_id);
参数同上。`&lt;/pre&gt;

#### /proc接口

当有多个硬件产生中断时，内核需要生成一份表格已记录中断和中断设备的情况，这个表格显示在/proc/interrupts中。

&lt;pre class=&quot;prettyprint&quot;&gt;`username@ubuntu:~$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7
  0:       4384          0          0          0          0          0          0          0   IO-APIC-edge      timer
  1:        950          2          0          1          0          0          0          0   IO-APIC-edge      i8042
  6:          0          0          0          0          0          0          3          0   IO-APIC-edge      floppy
  7:          0          0          0          0          0          0          0          0   IO-APIC-edge      parport0
  8:          1          0          0          0          0          0          0          0   IO-APIC-edge      rtc0
  9:          0          0          0          0          0          0          0          0   IO-APIC-fasteoi   acpi
 12:       3573          0          0          3          0          0          0          0   IO-APIC-edge      i8042
 14:          0          0          0          0          0          0          0          0   IO-APIC-edge      ata_piix
NMI:          0          0          0          0          0          0          0          0   Non-maskable interrupts
LOC:   34453497   34673929   33285941   33955988   26748072   26296607   25414863   26528495   Local timer interrupts
SPU:          0          0          0          0          0          0          0          0   Spurious interrupts
PMI:          0          0          0          0          0          0          0          0   Performance monitoring interrupts
IWI:          0          0          0          0          0          0          0          0   IRQ work interrupts
RES:   12987795   17430673   15115152   14059807   12072005   15228434   13090966   12469424   Rescheduling interrupts
CAL:       2382       2842       2895       2903    6002589       2717       2709       2523   Function call interrupts
TLB:    3183761    3010846    2658535    2572622    3065747    3268356    2652696    2713237   TLB shootdowns
TRM:          0          0          0          0          0          0          0          0   Thermal event interrupts
THR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts
MCE:          0          0          0          0          0          0          0          0   Machine check exceptions
MCP:       4340       4340       4340       4340       4340       4340       4340       4340   Machine check polls
ERR:          0
MIS:          0

第一列是已经安装的中断处理例程的中断号；
第二至九列分别是每个cpu收到的中断数量；
第十列是处理中断的可编程中断控制器信息；
第十一列是注册中断处理例程的设备信息。`&lt;/pre&gt;

还有一个和中断相关的文件：/proc/stat 

stat文件每行第一个字符串为该行的关键字，其中intr表示的正是中断相关的信息。 

intr后的第一列为接收的中断总数，之后为每个IRQ信号线接收的中断数量。

#### 自动探测IRQ号

驱动程序初始化时，通常需要确定设备将要使用哪条IRQ信号线以便正确的安装处理例程。自动探测IRQ号需要完成的功能是：通知设备产生一个中断信号并观察会发生什么。通常通过两种方法来实现这样的功能：调用内核提供的辅助函数，或者自己实现该功能。

##### **在内核帮助下探测**

内核提供了一些底层函数来探测中断号。它只能在非共享中断的情境下工作，但是大部分设备能够在共享中断状态工作，并且提供了更好的方法来尽量发现配置的中断号。

&lt;pre class=&quot;prettyprint&quot;&gt;`unsigned long probe_irq_on(void);
这个函数返回一个未安排的中断的位掩码. 驱动必须保留返回的位掩码, 并且在后面传递给 probe_irq_off。 在这个调用之后, 驱动应当安排它的设备产生至少一次中断。

int probe_irq_off(unsigned long);
在设备已请求一个中断后, 驱动调用这个函数, 作为参数传递之前由 probe_irq_on 返回的位掩码。probe_irq_off 返回在&quot;probe_on&quot;之后发出的中断号。如果没有中断发生, 返回 0 (因此, IRQ 0 不能探测, 但是没有用户设备能够在任何支持的体系上使用它). 如果多于一个中断发生( 模糊的探测 ), probe_irq_off 返回一个负值。
注意小心使能设备上的中断, 在调用 probe_irq_on 之后启用设备上的中断以及在调用 probe_irq_off 后禁止它们。另外, 在 probe_irq_off 之后需要处理设备上待处理的中断。`&lt;/pre&gt;

##### **实现自己的探测功能**

主要实现功能同上：通知设备产生一个中断信号并观察会发生什么。但实现自己的探测功能一般是启用所有未被占用的中断，然后观察会发生什么。

### 2 实现中断处理例程

类比定时器，实现中断处理例程的注意事项： 

1.不能向用户空间发送和接收数据，因为它不是在任何进程的上下文中执行的； 

2.不能做任何可能引发休眠的动作； 

3.不能调用schule函数； 

中断例程的功能：将有关中断接收的信息反馈给设备，并根据正在服务的中断的不同含义对数据进行相应的读和写。 

中断例程的典型任务：如果中断通知进程所等待的时间已经发生，就会唤醒在该设备上的休眠的进程。

#### 处理例程的参数及返回值

中断处理例程常用的三个参数： 

int irq：中断号，用于调试信息输出； 

void *dev_id：客户数据类型，一般是驱动程序的私有信息； 

struct pt_regs *regs：保存处理器进入中断代码前的处理器上下文快照（很少使用）； 

例：

&lt;pre class=&quot;prettyprint&quot;&gt;`//中断处理例程
static irqreturn_t sample_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
        struct sample_dev *dev = dev_id;
        /* now `dev&apos; points to the right hardware item */
        /* .... */
}
//和中断处理例程相关联的open代码
static void sample_open(struct inode *inode, struct file *filp)
{
        struct sample_dev *dev = hwinfo + MINOR(inode-&amp;gt;i_rdev);
        request_irq(dev-&amp;gt;irq, sample_interrupt,
                    0 /* flags */, &quot;sample&quot;, dev /* dev_id */);
        /*....*/
        return 0;

}`&lt;/pre&gt;

返回值： 

用于指明是否真正处理了一个中断，是则返回IRQ_HANDLED,否则返回IRQ_NONE；同时也可同过下面宏来产生返回值：IRQ_RETVAL(handled)。

#### 启用和禁用中断

禁止和启用单个中断：

&lt;pre class=&quot;prettyprint&quot;&gt;` &amp;lt;asm/irq.h&amp;gt;
 void disable_irq(int irq);
void disable_irq_nosync(int irq);
void enable_irq(int irq);`&lt;/pre&gt;

禁止和启用所有中断：

&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;asm/system.h&amp;gt;
void local_irq_save(unsigned long flags);
void local_irq_disable(void);
void local_irq_restore(unsigned long flags); 
void local_irq_enable(void);
</code></pre><h3 id="3-中断的顶半部和下半部"><a href="#3-中断的顶半部和下半部" class="headerlink" title="3 中断的顶半部和下半部"></a>3 中断的顶半部和下半部</h3><p>中断处理的一个主要问题是如何处理耗时任务。 </p>
<p>Linux (许多其他系统一起)通过将中断处理分为 2 部分解决这个问题。实际响应中断的例程，称为顶半部，也就是用request_irq注册的终端例程。底半部，被顶半部调度，并在稍后安全时间内执行的例程。 </p>
<p>linux有两种机制来实现底半部的处理：tasklet和工作队列。tasklet非常快，但是它的代码必须是原子的；工作队列具有更高的延迟，但允许休眠。这两种机制都在《时间、延迟和延缓操作》中讲到，这里略过。</p>
<h3 id="4-中断共享"><a href="#4-中断共享" class="headerlink" title="4 中断共享"></a>4 中断共享</h3><h4 id="安装共享处理例程"><a href="#安装共享处理例程" class="headerlink" title="安装共享处理例程"></a>安装共享处理例程</h4><p>共享中断通过 request_irq 来安装就像不共享的一样, 但是有 2 个不同: </p>
<p>1.当请求中断时，必须在 flags 参数中指定,SA_SHIRQ 位。 </p>
<p>2.dev_id 参数必须是唯一的。任何模块地址空间的指针都行, 但是 dev_id 明确地不能设置为 NULL。 </p>
<p>内核保持着一个与中断相关联的共享处理者列表, 并且 dev_id 可认为是区别它们的签名. 如果 2 个驱动要在同一个中断上注册 NULL 作为它们的签名, 在卸载时事情可能就乱了, 在中断到的时候引发内核 oops. 由于这个理由, 如果在注册共享中断时传给了一个 NULL dev_id , 现代内核会大声抱怨. 当请求一个共享的中断, request_irq 成功, 如果下列之一是真: </p>
<p>1.中断线空闲。 </p>
<p>2.所有这条线的已经注册的处理者也指定共享这个 IRQ。 </p>
<p>释放处理例程：free_irq。 </p>
<p>注意：不能使用enable_irq和disable_irq。如果使用了，共享中断信号线的其他设备就无法正常工作了。</p>
<h3 id="中断驱动的I-O"><a href="#中断驱动的I-O" class="headerlink" title="中断驱动的I/O"></a>中断驱动的I/O</h3><p>如果与驱动程序管理的硬件之间的数据传输因为某种原因而延迟, 驱动编写者应当实现缓冲。数据缓存有助于将数据的传送和接收与系统调用read和write分离开来，从而提高系统的性能。</p>
<p>一个好的缓存机制需采用中断驱动的 I/O，一个输入缓冲在中断时填充并且被读取设备的进程清空; 一个输出缓存由写设备的进程填充并且在中断时清空。 </p>
<p>为使中断驱动的数据传送成功发生, 硬件应当使用下列语义产生中断 : </p>
<p>1.对于输入, 当新数据到达时, 并且准备好被系统处理器获取时，设备中断处理器。实际动作依赖设备使用的是I/O 端口, 内存映射, 还是 DMA。 </p>
<p>2.对于输出, 或者当它准备好接受新数据, 或者确认一个成功的数据传送时，设备递交一个中断。 内存映射的和能DMA的设备常常产生中断来告诉系统它们完成了这个缓存。</p>
<pre><code>&lt;div&gt;
    作者：WEINILUO 发表于2016/9/29 17:30:10 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625432)
&lt;/div&gt;
&lt;div&gt;
阅读：483 评论：1 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625432#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-原-驱动中ioctl的使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/22/原-驱动中ioctl的使用/" class="article-date">
      <time datetime="2016-09-22T22:01:37.000Z" itemprop="datePublished">2016-09-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/22/原-驱动中ioctl的使用/">[原]驱动中ioctl的使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="1-ioctl调用"><a href="#1-ioctl调用" class="headerlink" title="1 ioctl调用"></a>1 ioctl调用</h3><pre><code>用户空间使用：
int ioctl(int fd,unsigned long cmd,...);
内核空间声明：
int (*ioctl)(struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg);`&lt;/pre&gt;

### 2 ioctl命令

&lt;pre class=&quot;prettyprint&quot;&gt;`内核约定了定义ioctl命令的相应方法，详细介绍见Documentation/ioctl/ioctl-number.txt和include/asm-generic/ioctl.h
定义ioctl命令的方法使用了4个位字段：type,number,direction,size
type:幻数字段（8bit）,根据ioctl-number.txt，选择一个号码在整个驱动中使用
number:序号字段（8bit），表示第几个命令号
direction:传输方向字段（2bit），表示数据传输方向
size:数据大小字段（14bit），表示数据传输的大小
命令构造方法：_IOC(direction,type,number,size)
常用构造命令的宏：
#define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size))
构造命令宏的使用：
#define CMD1 _IO(type,1)
#define CMD2R _IOR(type,2,int)
#define CMD3W _IOW(type,3,int)
`&lt;/pre&gt;

### 3 预定义命令

&lt;pre class=&quot;prettyprint&quot;&gt;`预定义命令有三类：
1.可用于任何文件的命令；
2.只用于普通文件的命令；
3.特定于文件系统类型的命令；
用于任何文件的常用预定义命令：
1.FIOCLEX:设置执行时关闭标志
2.FIONCLEX:清除执行时关闭标志
2.FIOASYNC:设置或复位文件异步通知
2.FIOQSIZE:返回文件或目录大小
2.FIONBIO:文件IO非阻塞型IO`&lt;/pre&gt;

### 4 ioctl参数使用

&lt;pre class=&quot;prettyprint&quot;&gt;`这里主要讨论ioctl的最后一个参数，该参数常常是指向用户空间的指针，但使用用户空间的指针必须保证合法，否则可能导致内核崩溃或其他安全问题。（copy_from_user和copy_to_user内部已经实现了相关的安全验证，所以不用关心这个问题）
因此，我们需要使用access_ok函数验证地址是否安全：
int access_ok(int type,const void *addr,unsigned long size);
type:VERIFY_READ/VERIFY_WRITE
size:参数大小`&lt;/pre&gt;

### 5 ioctl返回值

&lt;pre class=&quot;prettyprint&quot;&gt;`这里只讨论ioctl命令不匹配时的返回值，通常的做法是返回-EINVAL,但根据POSIX标准，应该返回-ENOTTY.

        &lt;div&gt;
            作者：WEINILUO 发表于2016/9/22 18:01:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625486)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：132 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625486#comments)
        &lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-原-时间、延迟及延缓操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/21/原-时间、延迟及延缓操作/" class="article-date">
      <time datetime="2016-09-21T21:15:35.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/原-时间、延迟及延缓操作/">[原]时间、延迟及延缓操作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="1-度量时间差"><a href="#1-度量时间差" class="headerlink" title="1.度量时间差"></a>1.度量时间差</h3><pre><code>内核通过定时器中断来跟踪时间流，时钟中断有系统定时硬件以周期性的间隔产生，这个间隔有内核根据HZ的值设定，HZ是一个与体系结构有关的常量，定义在&amp;lt;asm-generic/param.h&amp;gt;中。常用值为100或1000.每发生一次时钟中断，内核内部计数器的值增1，该值在系统引导时被初始化为0。该计数器是一个64位的变量（即使是32位架构也是这样），称为jiffies_64。但是驱动开发人员通常访问jiffies变量，它是unsigned long变量，通常是jiffies_64或者jiffies_64的低32位值。除了jiffy机制，某些cpu平台还有一个软件可读取的高分辨路计数器，以适用于特殊需求。
`&lt;/pre&gt;

#### 1.1 使用jiffies计数器

&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;linux/jiffies.h&amp;gt;
unsigned long j, stamp_1, stamp_half, stamp_n;

j = jiffies; /* read the current value */
stamp_1 = j + HZ; /* 1 second in the future */
stamp_half = j + HZ/2; /* half a second */
stamp_n = j + n * HZ / 1000; /* n milliseconds */

//当条件为真，返回真；
int time_after(unsigned long a, unsigned long b);//a&amp;gt;b
int time_before(unsigned long a, unsigned long b);//a&amp;lt;b
int time_after_eq(unsigned long a, unsigned long b);//a&amp;gt;=b
int time_before_eq(unsigned long a, unsigned long b);//a&amp;lt;=b
//计算时间差
diff = (long)t2 - (long)t1;
msec = diff * 1000 / HZ; 
//timespec、timeval与jiffies格式的转换
#include &amp;lt;linux/time.h&amp;gt; 
unsigned long timespec_to_jiffies(struct timespec *value);
void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);
unsigned long timeval_to_jiffies(struct timeval *value);
void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);
//在32位平台上原子的获取jiffies_64的值
#include &amp;lt;linux/jiffies.h&amp;gt; 
u64 get_jiffies_64(void);`&lt;/pre&gt;

#### 1.2 处理器特定的计数器

&lt;pre class=&quot;prettyprint&quot;&gt;`1.x86平台常用的TSC计数器寄存器：
它是一个 64-位 寄存器计数 CPU 的时钟周期; 它可从内核和用户空间读取.
&amp;lt;asm/msr.h&amp;gt;
rdtsc(low32,high32);
rdtscl(low32);
rdtscll(var64);
第一个宏自动读取 64位 值到 2 个 32位 变量;下一个读取寄存器的低半部到一个32位变量;最后一个读64位值到一个long long变量. 所有这些宏存储数值到它们的参数中.
2.体系无关函数get_cycles:
#include &amp;lt;linux/timex.h&amp;gt;
cycles_t get_cycles(void); 
在无时钟计数器的平台，返回0。
3.通过内嵌汇编实现：
#define rdtscl(dest) \
__asm__ __volatile__(&quot;mfc0 %0,$9; nop&quot; : &quot;=r&quot; (dest))`&lt;/pre&gt;

### 2.获取当前时间

内核通常通过查看 jifies 的值来获取当前时间，该数值表示最近一次系统启动到当前的时间间隔，他和设备驱动程序无关，因为他的生命周期只限于系统的运行周期。 

驱动程序一般不需要知道墙钟时间（日常时间，年月日的表达），只有cron、syslogd类似程序才需要知道。 

常用的时间相关函数：

&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/time.h&amp;gt; 
unsigned long mktime (unsigned int year, unsigned int mon, unsigned int day, unsigned int hour, unsigned int min, unsigned int sec); //将墙钟时间转化为jiffies值
void do_gettimeofday(struct timeval *tv);//返回当前时间，但很难原子获取timeval的两个变量
struct timespec current_kernel_time(void);//原子的获取当前时间`&lt;/pre&gt;

### 3.延迟执行

#### 3.1 长延迟

&lt;pre class=&quot;prettyprint&quot;&gt;`1.忙等待
如果想执行若干个时钟嘀嗒的延迟，或者对延迟的精度要求不高，可通过一下方法实现：
&amp;lt;linux/jiffies.h&amp;gt;
unsigned long j, j1;
j = jiffies;
j1=j+HZ;
while (time_before(jiffies, j1))
    cpu_relax();
注意: cpu_relax函数在许多系统上不会做任何事情，而在对称多线程系统上，它可能让出处理器。但是通常情况下我们都应避免这种方式，因为这会严重降低系统性能。在非抢占系统上，在延迟过程中会锁住处理器；如果在进入忙等待前禁止了中断，jiffies值变得不到更新，系统就会死掉！
2.让出处理器
上面忙等待的方法会增加系统的负担，但延迟的实现有多种方法。延迟的另一种实现方式如下：
&amp;lt;linux/jiffies.h&amp;gt;
unsigned long j, j1;
j = jiffies;
j1=j+HZ;
while (time_before(jiffies, j1))
    schedule();
注意：这种方式释放了cpu而不做任何事情，但他仍在运行队列中。若系统中只有当前进程运行，这当前进程会立即执行，因此，系统一直处于运行中，空闲任务不会运行，cpu并没有空闲下来。从cpu的角度看，这种方式和忙等待类似。
3.超时
上面两种方式都会给cpu带来负担，目前最好的方式是让内核完成我们的任务。当前有两种构造基于jiffies超时的途径，这主要取决于驱动程序是否在等待其他事件。
第一种途径，驱动程序使用等待队列等待其他一些事件：
#include &amp;lt;linux/wait.h&amp;gt;
long wait_event_timeout(wait_queue_head_t q, condition, long timeout);
long wait_event_interruptible_timeout(wait_queue_head_t q, condition, long timeout);
参数：
q:队列头
condition：条件
timeout：返回要等待的事件的jiffies值
返回：
若是被其他时间唤醒，返回剩余的jiffies值；若是超时到期，返回0。
例：
#include &amp;lt;linux/wait.h&amp;gt;
wait_queue_head_t wait; 
init_waitqueue_head (&amp;amp;wait); 
wait_event_interruptible_timeout(wait, 0, delay); 
第二种途径，驱动程序无需等待其他事件：
#include &amp;lt;linux/sched.h&amp;gt;
signed long schedule_timeout(signed long timeout);
参数：
timeout：延迟时间的jiffies值；
返回：
正常返回0；
注意：使用schedule_timeout前需要设置当前进程的状态
例：
set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout (delay);`&lt;/pre&gt;

#### 3.2 短延迟

&lt;pre class=&quot;prettyprint&quot;&gt;`如果驱动程序需要处理硬件的延迟，这种延迟通常最多涉及到几十个毫秒。这是通常用ndelay、udelay,以及 mdelay来完成延迟任务。
#include &amp;lt;linux/delay.h&amp;gt;
void ndelay(unsigned long nsecs);
void udelay(unsigned long usecs);
void mdelay(unsigned long msecs);
这三个方法都是忙等待函数，当然不涉及忙等待的方法也有相应的实现：
void msleep(unsigned int millisecs);
unsigned long msleep_interruptible(unsigned int millisecs);
void ssleep(unsigned int seconds);`&lt;/pre&gt;

### 4.内核定时器

内核定时器使用场景：在将来的某个时间点调度执行某个函数，同时在该时间点到达之前不会阻塞当前进程。 

内核定时器常常作为软件中断的结果而运行的，被调度运行的函数几乎不会再注册这些函数的进程正在执行是运行。在这种原子性的上下文中运行时，定时器函数必须以原子的方式运行（请参照自旋锁和原子上下文相关内容）。定时器函数通常需要遵循以下规则： 

1.不允许访问用户空间，因为没有进程上下文，无法将任何特定进程和用户空间关联。 

2.current指针在原子模式下无任何意义，因为相关的代码和被中断的进程没有任何关联。 

3.不能执行休眠和调度，原子代码不能调用 schedule 或者某种 wait_event, 也不能调用任何其他可能睡眠的函数.。例如, 调用 kmalloc(…, GFP_KERNEL) 是违犯规则的. 旗标也必须不能使用因为它们可能睡眠。 

in_interrupt()和in_atomic(): 

包含在&amp;lt; asm/hardirq.h&amp;gt;中；都是用于内核代码判断自己是否处于中断上下文的函数，但是后者可以用在调度不被允许的情况下，包括硬件中断和软件中断上下文以及拥有自旋锁的任何时间点。 

注意：任何定时器函数访问的数据结构都应该针对并发访问进行保护。

#### 4.1 定时器API

&lt;pre class=&quot;prettyprint&quot;&gt;`内核提供给驱动许多函数来声明, 注册, 以及去除内核定时器. 下列的引用展示了基本的代码块:
#include &amp;lt;linux/timer.h&amp;gt;
struct timer_list
{
        /* ... */
        unsigned long expires;
        void (*function)(unsigned long);
        unsigned long data;
};
void init_timer(struct timer_list *timer);
struct timer_list TIMER_INITIALIZER(_function, _expires, _data);

void add_timer(struct timer_list * timer);
int del_timer(struct timer_list * timer);

//更新某个定时器的到期时间
int mod_timer(struct timer_list *timer, unsigned long expires);
//和del_timer类似，但是del_timer_sync确保返回时没有任何CPU在运行定时器函数
int del_timer_sync(struct timer_list *timer);
//返回定时器是否正在被调度运行
int timer_pending(const struct timer_list * timer);`&lt;/pre&gt;

#### 4.2 内核定时器的实现

&lt;pre class=&quot;prettyprint&quot;&gt;`内核定时器的实现要求：
1.定时器的管理必须做到轻量级；
2.其设计必须在活动定时器大量增加时具有良好的伸缩性；
3.大部分定时器会在最多几秒或者几分钟内到期，很少存在长期延迟的定时器；
4.定时器应该在注册他的当前cpu上运行。

目前的解决方案是利用per-CPU数据结构。
无论何时内核代码注册一个定时器( 通过 add_timer 或者 mod_timer), 最终由 internal_add_timer ( 在kernel/timer.c)执行, 它依次添加新定时器到一个双向定时器链表在一个关联到当前 CPU 的&quot;级联表&quot; 中。
级联表的工作工作方式: 如果定时器在下一个 0 到 255 jiffies 内到期, 则它会被添加到专供短时定时器 256 列表中的一个（这取决于expires 成员的低8位）。如果它在将来更久时间到期（但是在 16,384 jiffies 之前), 它会被添加到基于 expires 成员的 9 - 14 位的 64 个列表中一个. 对于更长的定时器, 同样的技巧用在 15 - 20 位, 21 - 26 位, 和 27 - 31 位. 带有一个指向将来还长时间的 expires 成员的定时器（一些只可能发生在 64-位 平台上的事情）被使用一个延时值 0xffffffff 进行哈希处理, 而在过去时间内到期的定时器将在下一个时钟嘀哒被调度（如果在高负荷情况，有可能注册一个已经到期的定时器，尤其在运行抢占式内核时）。
当触发 __run_timers, 它为当前定时器嘀哒执行所有挂起的定时器。如果当前jiffies是256的倍数, 这个函数还会将下一级定时器链表重新散列到256个短期列表中, 同时还可能根据上面jiffies的位划分对其他级别的定时器做级联处理。`&lt;/pre&gt;

### 5.tasklet

另一个有关于定时问题的内核设施是 tasklet 机制. 它大部分用在中断管理。

#### 5.1 tasklet 与内核定时器的异同

1.它们一直在中断时间运行； 

2.它们一直运行在调度它们的同一个 CPU 上； 

3.它们接收一个 unsigned long 参数； 

4.它们都在“软件中断”上下文原子性执行； 

5.tasklet无法请求在一个指定的时间执行函数，调度tasklet，表示我们只希望内核在其后的某个时间执行指定的函数（因此适用于中断管理）。

#### 5.2 tasklet 的特色

1.tasklet 能够被禁止之后能被重新使能; 它不会执行直到它被使能与被禁止相同的次数； 

2.tasklet 可以注册它自己； 

3.tasklet 能以正常的优先级或者高优先级被调度执行，后一组一直是首先执行； 

4.如果系统负荷不重，taslet 能立刻运行,  但是不会晚于下一个时钟嘀哒； 

5.tasklet 可能和其他 tasklet 并发, 但是对它自己是严格地串行的，因为它始终会在地调度自己的同一cpu上运行，从不运行在不同的处理器上。

#### 5.3 tasklet使用

&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/interrupt.h&amp;gt; 
struct tasklet_struct {
 /* ... */

void (*func)(unsigned long);
 unsigned long data;
};

void tasklet_init(struct tasklet_struct *t,
void (*func)(unsigned long), unsigned long data);
DECLARE_TASKLET(name, func, data);
DECLARE_TASKLET_DISABLED(name, func, data);
//禁用指定的tasklet
void tasklet_disable(struct tasklet_struct *t);
//禁用指定的tasklet，但不会等待任何正在运行的tasklet退出
void tasklet_disable_nosync(struct tasklet_struct *t);
//启用之前被禁用的tasklet
void tasklet_enable(struct tasklet_struct *t);
//调度指定的tasklet
void tasklet_schedule(struct tasklet_struct *t);
//禁用指定的tasklet以高优先级执行
void tasklet_hi_schedule(struct tasklet_struct *t);
//禁止指定的tasklet的再次调度，通用用于设备关闭和模块移除
void tasklet_kill(struct tasklet_struct *t);`&lt;/pre&gt;

### 6.工作队列

工作队列类似于tasklet，他们都允许内核代码请求某个函数在将来的时间被调用，当时两者之间还是有一些非常重要的区别： 

1.tasklet 在软件中断上下文中运行的结果是所有的 tasklet 代码必须是原子的；相反, 工作队列函数在一个特殊内核进程上下文运行，所以它们有更多的灵活性。注意, 工作队列函数能够睡眠。 

2.tasklet 常常在它们最初被提交的处理器上运行。但这只是工作队列默认的工作方式。 

3.内核代码可以请求工作队列函数被延后指定的时间间隔后执行。 

4.tasklet会在很短的会时间内很快的执行, 并且在原子态, 而工作队列函数可能有更长的延迟而且不需要是原子的。

#### 6.1 工作队列的使用

&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;linux/workqueue.h&amp;gt;
//创建工作队列
struct workqueue_struct *create_workqueue(const char *name);
struct workqueue_struct *create_singlethread_workqueue(const char *name);
//编译时向工作队列递交任务
DECLARE_WORK(name, void (*function)(void *), void *data);
//运行时构造work_struct 结构
//INIT_WORK完成所有初始化工作
INIT_WORK(struct work_struct *work, void (*function)(void *), void *data); 
//同INIT_WORK，但不会初始化用来将work_struct结构连接到工作队列的指针
PREPARE_WORK(struct work_struct *work, void (*function)(void *), void *data); 
//将工作递交到工作队列
int queue_work(struct workqueue_struct *queue, struct work_struct *work);
int queue_delayed_work(struct workqueue_struct *queue, struct work_struct *work, unsigned long delay);
//取消某个挂起的工作队列入口项
int cancel_delayed_work(struct work_struct *work); 
//禁止运行被调用之前所有被递交的工作
void flush_workqueue(struct workqueue_struct *queue); 
//释放工作队列
void destroy_workqueue(struct workqueue_struct *queue); `&lt;/pre&gt;

#### 6.2 共享队列

设备驱动, 在许多情况下, 不需要有它自己的工作队列。如果你只偶尔需要提交任务给队列, 简单地使用内核提供的共享的默认工作队列可能更有效。如果你需要使用这个队列，你必须明白你将和别的在共享它，这意味着你不应当长时间独占队列(无长睡眠), 并且可能要更长时间我们的任务才能获得处理器。 

1.共享队列使用：

&lt;pre class=&quot;prettyprint&quot;&gt;`//递交工作任务
int schedule_work(struct work_struct *work); 
//以延迟模式递交工作任务
int schedule_delayed_work(struct work_struct *work, unsigned long delay); 
//刷新共享队列
void flush_scheduled_work(void); 
例：
static struct work_struct jiq_work;
/* this line is in jiq_init() */
INIT_WORK(&amp;amp;jiq_work, jiq_print_wq, &amp;amp;jiq_data);
prepare_to_wait(&amp;amp;jiq_wait, &amp;amp;wait, TASK_INTERRUPTIBLE);
schedule_work(&amp;amp;jiq_work);
schedule();
finish_wait(&amp;amp;jiq_wait, &amp;amp;wait);

        &lt;div&gt;
            作者：WEINILUO 发表于2016/9/21 17:15:35 [原文链接](http://blog.csdn.net/weiniluo/article/details/52540396)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：99 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52540396#comments)
        &lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-原-I2C协议" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/18/原-I2C协议/" class="article-date">
      <time datetime="2016-09-18T13:49:16.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/原-I2C协议/">[原]I2C协议</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="1-协议"><a href="#1-协议" class="headerlink" title="1.协议"></a>1.协议</h3><pre><code>1.空闲状态：
    SCL=H&amp;amp;&amp;amp;SDA=H
2.起始位和停止位:
    start bit:
        SCL=H&amp;amp;&amp;amp;SDA↓
    stop bit:
        SCL=H&amp;amp;&amp;amp;SDA↑
3.ACK
    发送器每发送完一个字节，就在第9个CLK释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。

4.数据有效性
    I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。 

5.主从设备
    系统中的所有外围器件都具有一个7位的&quot;从器件专用地址码&quot;，其中高4位为器件类型，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义。所以同一厂家的同一器件最多只能在同一个I2C总线上挂在8片。
`&lt;/pre&gt;

### 2.读写流程

#### 2.1写流程

&lt;pre class=&quot;prettyprint&quot;&gt;`1.start bit
2.send slave address+write bit
3.check ack
4.send reg address
5.check ack
6.send data
7.check ack
8.stop bit`&lt;/pre&gt;

#### 2.2读流程

&lt;pre class=&quot;prettyprint&quot;&gt;`1.start bit
2.send slave address+write bit
3.check ack
4.send reg address
5.check ack
6.start bit
7.send slave address+read bit
8.check ack
9.read data
10.stop bit

        &lt;div&gt;
            作者：WEINILUO 发表于2016/9/18 9:49:16 [原文链接](http://blog.csdn.net/weiniluo/article/details/51790017)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：86 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51790017#comments)
        &lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-转-attribute-机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/12/转-attribute-机制/" class="article-date">
      <time datetime="2016-09-12T14:41:13.000Z" itemprop="datePublished">2016-09-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/12/转-attribute-机制/">[转]__attribute__机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>内核中常会用到<strong>attribute</strong>，今天仔细了解一下这个<strong>attribute</strong>机制。</p>
<h3 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h3><p><strong>attribute</strong>可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。它的书写特征是：<strong>attribute</strong>前后都有两个下划线，后面attribute-list是相应的<strong>attribute</strong>参数，语法格式如下： </p>
<p><strong>attribute</strong> ((attribute-list)) </p>
<p>另外，它必须放于声明的尾部“；”之前。</p>
<h3 id="2-函数属性"><a href="#2-函数属性" class="headerlink" title="2.函数属性"></a>2.函数属性</h3><p>函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。<strong>attribute</strong>机制也很容易同非GNU应用程序做到兼容之功效。 </p>
<pre><code>GNU CC需要使用 –Wall编译器来击活该功能，这是控制警告信息的一个很好的方式。下面介绍几个常见的属性参数。 

**attribute** format。该**attribute**属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。format的语法格式为： 
</code></pre><p>format (archetype, string-index, first-to-check) </p>
<p>format属性告诉编译器，按照printf, scanf, strftime或strfmon的参数表格式规则对该函数的参数进行检查。“archetype”指定是哪种风格；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定从函数的第几个参数开始按上述规则进行检查。 </p>
<p>具体使用格式如下： </p>
<p><strong>attribute</strong>((format(printf,m,n))) </p>
<p><strong>attribute</strong>((format(scanf,m,n))) </p>
<p>其中参数m与n的含义为： </p>
<p>m：第几个参数为格式化字符串（format string）； </p>
<p>n：参数集合中的第一个，即参数“…”里的第一个参数在函数参数总数排在第几，注意，有时函数参数里还有“隐身”的呢，后面会提到； </p>
<pre><code>在使用上，**attribute**((format(printf,m,n)))是常用的，而另一种却很少见到。下面举例说明，其中myprint为自己定义的一个带有可变参数的函数，其功能类似于printf： 
</code></pre><p>//m=1；n=2 </p>
<p>extern void myprint(const char <em>format,…) <em>*attribute</em></em>((format(printf,1,2))); </p>
<p>//m=2；n=3 </p>
<p>extern void myprint(int l，const char <em>format,…) <em>*attribute</em></em>((format(printf,2,3))); </p>
<p>需要特别注意的是，如果myprint是一个函数的成员函数，那么m和n的值可有点“悬乎”了，例如： </p>
<p>//m=3；n=4 </p>
<p>extern void myprint(int l，const char <em>format,…) <em>*attribute</em></em>((format(printf,3,4))); </p>
<pre><code>其原因是，类成员函数的第一个参数实际上一个“隐身”的“this”指针。（有点C++基础的都知道点this指针，不知道你在这里还知道吗？） 

这里给出测试用例：attribute.c，代码如下： 
</code></pre><p>[cpp] view plain copy </p>
<p>extern void myprint(const char <em>format,…) <em>*attribute</em></em>((format(printf,1,2))); </p>
<pre><code>void test() 

{ 

    myprint(“i=%d\n”,6); 

    myprint(“i=%s\n”,6); 

    myprint(“i=%s\n”,”abc”); 

    myprint(“%s,%d,%d\n”,1,2); 

} 

gcc编译后会提示format argument is not a pointer的警告。若去掉**attribute**((format(printf,1,2)))，则会正常编译。需要注意的是，编译器只能识别类似printf的标准输出库函数。 

还有一个**attribute** noreturn，该属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。C库函数中的abort()和exit()的声明格式就采用了这种格式，如下所示：  
</code></pre><p>extern void exit(int)   <strong>attribute</strong>((noreturn)); </p>
<p>extern void abort(void) <strong>attribute</strong>((noreturn)); </p>
<p>为了方便理解，大家可以参考如下的例子： </p>
<p>[cpp] view plain copy </p>
<p>//name: noreturn.c  ；测试<strong>attribute</strong>((noreturn)) </p>
<pre><code>extern void myexit(); 

int test(int n) 

{ 

    if ( n &amp;gt; 0 ) 

    { 

        myexit(); 

        /* 程序不可能到达这里*/ 

    } 

    else 

        return 0; 

} 
</code></pre><p>编译后的输出结果如下： </p>
<p>$gcc –Wall –c noreturn.c </p>
<p>noreturn.c: In function `test’: </p>
<p>noreturn.c:12: warning: control reaches end of non-void function </p>
<pre><code>很显然，这是因为一个被定义为有返回值的函数却没有返回值。加上**attribute**((noreturn))则可以解决此问题的出现。 

后面还有__attribute__const、-finstrument-functions、no_instrument_function等的属性描述，就不多转了，感兴趣的可以看原文。
</code></pre><h3 id="3-变量属性-Variable-Attribute"><a href="#3-变量属性-Variable-Attribute" class="headerlink" title="3.变量属性(Variable Attribute)"></a>3.变量属性(Variable Attribute)</h3><pre><code>关键字__attribute__也可以对变量或结构体成员进行属性设置。这里给出几个常用的参数的解释，更多的参数可参考原文给出的连接。
在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。
`&lt;/pre&gt;

aligned (alignment) 

该属性规定变量或结构体成员的最小的对齐格式，以字节为单位。例如： 

int x **attribute** ((aligned (16))) = 0; 

    编译器将以16字节（注意是字节byte不是位bit）对齐的方式分配一个变量。也可以对结构体成员变量设置该属性，例如，创建一个双字对齐的int对，可以这么写： 

struct foo { int x[2] **attribute** ((aligned (8))); }; 

    如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： 

short array[3] **attribute** ((aligned)); 

    选择针对目标机器最大的对齐方式，可以提高拷贝操作的效率。aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 

    需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 

    使用该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。 

    下面的例子中，x成员变量使用了该属性，则其值将紧放置在a的后面：  

       struct test 

          { 

            char a; 

            int x[2] **attribute** ((packed)); 

          }; 

    其它可选的属性值还可以是：cleanup，common，nocommon，deprecated，mode，section，shared，tls_model，transparent_union，unused，vector_size，weak，dllimport，dlexport等。

### 4.类型属性（Type Attribute）

&lt;pre&gt;`关键字__attribute__也可以对结构体（struct）或共用体（union）进行属性设置。大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias。
在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。
</code></pre><p>aligned (alignment) </p>
<p>该属性设定一个指定大小的对齐格式（以字节为单位），例如：  </p>
<p>struct S { short f[3]; } <strong>attribute</strong> ((aligned (8))); </p>
<p>typedef int more_aligned_int <strong>attribute</strong> ((aligned (8))); </p>
<pre><code>该声明将强制编译器确保（尽它所能）变量类型为struct S或者more-aligned-int的变量在分配空间时采用8字节对齐方式。 

如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： 
</code></pre><p>struct S { short f[3]; } <strong>attribute</strong> ((aligned)); </p>
<p>这里，如果sizeof（short）的大小为2（byte），那么，S的大小就为6。取一个2的次方值，使得该值大于等于6，则该值为8，所以编译器将设置S类型的对齐方式为8字节。 </p>
<p>aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 </p>
<p>需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 </p>
<pre><code>使用该属性对struct或者union类型进行定义，设定其类型的每一个变量的内存约束。当用在enum类型定义时，暗示了应该使用最小完整的类型（it indicates that the smallest integral type should be used）。 

下面的例子中，my-packed-struct类型的变量数组中的值将会紧紧的靠在一起，但内部的成员变量s不会被“pack”，如果希望内部的成员变量也被packed的话，my-unpacked-struct也需要使用packed进行相应的约束。  
</code></pre><p>struct my_unpacked_struct </p>
<p>{ </p>
<pre><code>char c; 

int i; 
</code></pre><p>};</p>
<p>struct my_packed_struct </p>
<p>{ </p>
<pre><code>char c; 

int  i; 

struct my_unpacked_struct s; 
</code></pre><p>}<strong>attribute</strong> ((<strong>packed</strong>));</p>
<pre><code>&lt;div&gt;
    作者：WEINILUO 发表于2016/9/12 10:41:13 [原文链接](http://blog.csdn.net/weiniluo/article/details/52510949)
&lt;/div&gt;
&lt;div&gt;
阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52510949#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-原-Device-Tree-入门" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/26/原-Device-Tree-入门/" class="article-date">
      <time datetime="2016-08-26T18:15:06.000Z" itemprop="datePublished">2016-08-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/26/原-Device-Tree-入门/">[原]Device Tree 入门</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>1.写在前面 </p>
<p>本文是本人在阅读了蜗窝科技的Device Tree三篇文章后的笔记，他的这几篇文章是我最近了解到的在Device Tree方面讲的比较深入细致的，非常感谢蜗窝科技为我们提供的学习机会，如果有需要，请你们去<a href="http://www.wowotech.net/device_model/why-dt.html" target="_blank" rel="external">蜗窝科技</a>。 </p>
<p>2.Device Tree结构</p>
<pre><code>kernel/arch/arm/boot/dts/skeleton.dtsi:
/ {
    #address-cells = &amp;lt;1&amp;gt;;
    #size-cells = &amp;lt;1&amp;gt;;
    cpus { };
    soc { };
    chosen { };
    aliases { };
    memory { device_type = &quot;memory&quot;; reg = &amp;lt;0 0&amp;gt;; };
};
kernel/arch/arm/boot/dts/qcom/skeleton.dtsi:
#include &quot;skeleton64.dtsi&quot;
#include &amp;lt;dt-bindings/clock/msm-clocks-8953.h&amp;gt;
#include &amp;lt;dt-bindings/regulator/qcom,rpm-smd-regulator.h&amp;gt;
#include &amp;lt;dt-bindings/gpio/gpio.h&amp;gt;
/ {
    model = &quot;Qualcomm Technologies, Inc. MSM 8953&quot;;
    compatible = &quot;qcom,msm8953&quot;;
    qcom,msm-id = &amp;lt;293 0x0&amp;gt;;
    interrupt-parent = &amp;lt;&amp;amp;intc&amp;gt;;

    chosen {
        bootargs = &quot;sched_enable_hmp=1 sched_enable_power_aware=1&quot;;
    };

    reserved-memory {
        #address-cells = &amp;lt;2&amp;gt;;
        #size-cells = &amp;lt;2&amp;gt;;
        ranges;

        other_ext_mem: other_ext_region@0 {
            compatible = &quot;removed-dma-pool&quot;;
            no-map;
            reg = &amp;lt;0x0 0x83300000 0x0 0x3800000&amp;gt;;
        };

        modem_mem: modem_region@0 {
            compatible = &quot;removed-dma-pool&quot;;
            no-map-fixup;
            reg = &amp;lt;0x0 0x86c00000 0x0 0x5600000&amp;gt;;
        };

        reloc_mem: reloc_region@0 {
            compatible = &quot;removed-dma-pool&quot;;
            no-map;
            reg = &amp;lt;0x0 0x8c200000 0x0 0x1800000&amp;gt;;
        };

        venus_mem: venus_region@0 {
            compatible = &quot;shared-dma-pool&quot;;
            reusable;
            alloc-ranges = &amp;lt;0x0 0x80000000 0x0 0x10000000&amp;gt;;
            alignment = &amp;lt;0 0x400000&amp;gt;;
            size = &amp;lt;0 0x0800000&amp;gt;;
        };

        secure_mem: secure_region@0 {
            compatible = &quot;shared-dma-pool&quot;;
            reusable;
            alignment = &amp;lt;0 0x400000&amp;gt;;
            size = &amp;lt;0 0x09800000&amp;gt;;
        };

        qseecom_mem: qseecom_region@0 {
            compatible = &quot;shared-dma-pool&quot;;
            reusable;
            alignment = &amp;lt;0 0x400000&amp;gt;;
            size = &amp;lt;0 0x1000000&amp;gt;;
        };

        adsp_mem: adsp_region@0 {
            compatible = &quot;shared-dma-pool&quot;;
            reusable;
            size = &amp;lt;0 0x400000&amp;gt;;
        };

        dfps_data_mem: dfps_data_mem@90000000 {
               reg = &amp;lt;0 0x90000000 0 0x1000&amp;gt;;
               label = &quot;dfps_data_mem&quot;;
        };

        cont_splash_mem: splash_region@0x90001000 {
            reg = &amp;lt;0x0 0x90001000 0x0 0x13ff000&amp;gt;;
            label = &quot;cont_splash_mem&quot;;
        };

        gpu_mem: gpu_region@0 {
            compatible = &quot;shared-dma-pool&quot;;
            reusable;
            alloc-ranges = &amp;lt;0x0 0x80000000 0x0 0x10000000&amp;gt;;
            alignment = &amp;lt;0 0x400000&amp;gt;;
            size = &amp;lt;0 0x800000&amp;gt;;
        };
    };

    aliases {
        /* smdtty devices */
        smd1 = &amp;amp;smdtty_apps_fm;
        smd2 = &amp;amp;smdtty_apps_riva_bt_acl;
        smd3 = &amp;amp;smdtty_apps_riva_bt_cmd;
        smd4 = &amp;amp;smdtty_mbalbridge;
        smd5 = &amp;amp;smdtty_apps_riva_ant_cmd;
        smd6 = &amp;amp;smdtty_apps_riva_ant_data;
        smd7 = &amp;amp;smdtty_data1;
        smd8 = &amp;amp;smdtty_data4;
        smd11 = &amp;amp;smdtty_data11;
        smd21 = &amp;amp;smdtty_data21;
        smd36 = &amp;amp;smdtty_loopback;
        sdhc1 = &amp;amp;sdhc_1; /* SDC1 eMMC slot */
        sdhc2 = &amp;amp;sdhc_2; /* SDC2 for SD card */
        i2c1 = &amp;amp;i2c_1;
        i2c2 = &amp;amp;i2c_2;
        i2c3 = &amp;amp;i2c_3;
        i2c5 = &amp;amp;i2c_5;
        spi3 = &amp;amp;spi_3;
    };

    soc: soc { };

};
由上面的例子看出Device Tree有一下特点：
1.节点node
    1.1每个node可以包含sub node和property/value；
    1.2每个DTS都只有一个ROOT node；
    1.3一个node可以有多个sub node，但只能有一个parent node；
    1.4一个node可以包含多个property/value描述该node的具体信息；
    1.5每个node用节点名字（node name）标识，节点名字的格式是node-name@unit-address。如果该node没有reg属性（后面会描述这个property），那么该节点名字中必须不能包括@和unit-address。
2.属性/值property/value
    2.1一般属性：
    属性值表示了该设备节点的具体特性，它的值是多样性的：
    1)可能为空，即没有值的定义；
    2)可能为32bit或64bit整数值(#size-cells = &amp;lt;2&amp;gt;)或者数组(reg = &amp;lt;0x0 0x86c00000 0x0 0x5600000&amp;gt;)；
    3）可能为string(label = &quot;cont_splash_mem&quot;)或string list(compatible = &quot;qcom,msm8953&quot;)；
    2.2特殊属性：
    #address-cells = &amp;lt;1&amp;gt;;
    #size-cells = &amp;lt;0&amp;gt;;
    #类似number，#address-cells表示子节点中reg中的地址元素需要用多少个32bit值来表示，#size-cells表示子节点中reg中的大小元素需要用多少个32bit值来表示。`&lt;/pre&gt;

3.Device Tree source file语法

&lt;pre class=&quot;prettyprint&quot;&gt;`1.节点定义：
    [label:] node-name[@unit-address] { 
       [properties definitions];
       [child nodes];
    };
2.节点引用：
    1)直接引用：绝对路径，/node-name-1/node-name-2/node-name-N；
    2)别名引用：所有别名被定义在节点aliases中；
    3)lable引用：&amp;amp;lable；
3.属性定义：
    property ＝ value;
    再次注意value的三种方式：
    1)32bit unsigned integers：#size-cells = &amp;lt;2&amp;gt;;
    2)binary data：binary-property = [0x01 0x23 0x45 0x67];
    3)string/string list：device_type = &quot;memory&quot;;

        &lt;div&gt;
            作者：WEINILUO 发表于2016/8/26 14:15:06 [原文链接](http://blog.csdn.net/weiniluo/article/details/52326801)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52326801#comments)
        &lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-原-c-差缺补漏" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/25/原-c-差缺补漏/" class="article-date">
      <time datetime="2016-08-25T14:08:29.000Z" itemprop="datePublished">2016-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/25/原-c-差缺补漏/">[原]c 差缺补漏</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>1.类型转换 </p>
<p>1.1自动转换</p>
<pre><code>高        double    ←←    float
↑          ↑             
↑         long     
↑          ↑
↑        unsigned
↑          ↑
低         int      ←←    char,short`&lt;/pre&gt;

规则：在进行自动类型转换的时候，如果原来的数是无符号数，那么在扩展的时候，高位填充的是0；如果是有符号数，那么高位填充的时符号位！这一点有点类似于“&amp;gt;&amp;gt;”操作符，当无符号数右移的时候，高位填充的是0；有符号数右移的时候，高位填充的是符号位。

&lt;pre class=&quot;prettyprint&quot;&gt;`  1 #include &amp;lt;stdio.h&amp;gt;
  2
  3 int main()
  4 {
  5     char v16s;
  6     unsigned char v16u;
  7     int v32s;
  8     unsigned int v32u;
  9     v16s=0xfb;
 10     v16u=(unsigned char)v16s;
 11     v32s=(int)v16s;
 12     v32u=(unsigned int)v16s;
 13     printf(&quot;v16u:%x,v32s:%x,v32u:%x\n&quot;,v16u,v32s,v32u);
 14     v16s=0x0b;
 15     v32s=(int)v16s;
 16     v32u=(unsigned int)v16s;
 17     printf(&quot;v32s:%x,v32u:%x\n&quot;,v32s,v32u);
 18     v32s=0xfffffffb;
 19     v16s=(char)v32s;
 20     v16u=(unsigned char)v32s;
 21     printf(&quot;v16s:%x,v16u:%x\n&quot;,v16s,v16u);
 22     v16s=0xfb;
 23     v16u=0xfb;
 24     v32s=(int)v16s;
 25     v32u=(unsigned char)v16u;
 26     printf(&quot;v32s:%x,v32u:%x\n&quot;,v32s,v32u);
 27
 28     return 0;
 29 }

        &lt;div&gt;
            作者：WEINILUO 发表于2016/8/25 10:08:29 [原文链接](http://blog.csdn.net/weiniluo/article/details/52303134)
        &lt;/div&gt;
        &lt;div&gt;
        阅读：104 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52303134#comments)
        &lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-原-ubuntu-定时任务" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/24/原-ubuntu-定时任务/" class="article-date">
      <time datetime="2016-08-24T17:58:32.000Z" itemprop="datePublished">2016-08-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/24/原-ubuntu-定时任务/">[原]ubuntu 定时任务</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>1.编辑/etc/crontab文件</p>
<pre><code># /etc/crontab: system-wide crontab
# Unlike any other crontab you don&apos;t have to run the `crontab&apos;
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# m h dom mon dow user  command
17 *    * * *   root    cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.weekly )
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.monthly )
#
10 6    * * *   zhanglei run-parts /home/zhanglei/zlwork/script/

注：
1.注释
    m h dom mon dow user  command
    m 0-59的数值，*表示任何数值都执行
    h 0-23的数值，*表示任何数值都执行
    dom 1-31的数值，*表示任何数值都执行
    mon 1-12的数值，*表示任何数值都执行
    dow 0-7的数值，*表示任何数值都执行,0/7代表周日
    user 表示以某个用户身份执行命令
    command 需要执行的脚本或命令（直接为命令或脚本文件或者run-parts 脚本文件目录）

2.或者用crontab -e 为当前用户创建cron任务   
3.脚本文件注意PATH引用
    由于cron是系统进程，脚本的执行经常会受到环境变量的影响，因此需要格外小心，例如我的环境变量：
    export PATH=~/bin:$PATH:/sbin
</code></pre><p>2.service cron restart</p>
<p>参考文章： </p>
<p><a href="http://blog.csdn.net/liu414226580/article/details/16339935" target="_blank" rel="external">http://blog.csdn.net/liu414226580/article/details/16339935</a> </p>
<p><a href="http://blog.csdn.net/wide288/article/details/8765951" target="_blank" rel="external">http://blog.csdn.net/wide288/article/details/8765951</a></p>
<pre><code>&lt;div&gt;
    作者：WEINILUO 发表于2016/8/24 13:58:32 [原文链接](http://blog.csdn.net/weiniluo/article/details/52299236)
&lt;/div&gt;
&lt;div&gt;
阅读：90 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52299236#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-原-list-for-each-entry深入理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/03/原-list-for-each-entry深入理解/" class="article-date">
      <time datetime="2016-08-03T18:49:58.000Z" itemprop="datePublished">2016-08-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/03/原-list-for-each-entry深入理解/">[原]list_for_each_entry深入理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在内核编程中经常会遇到list_for_each_entry(pos, head, member)，今天深入分析一下list_for_each_entry在内核中是如何定义的。 </p>
<p>list_for_each_entry主要作用是遍历给定类型的链表，被定义在include/linux/list.h中：</p>
<pre><code>/**
 * list_for_each_entry  -   iterate over list of given type
 * @pos:    the type * to use as a loop cursor.
 * @head:   the head for your list.
 * @member: the name of the list_struct within the struct.
 */
#define list_for_each_entry(pos, head, member)              \
    for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member);  \
         &amp;amp;pos-&amp;gt;member != (head);    \
         pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))`

接着需要理解list_entry，list_entry的作用是获取条目的结构类型，同样被定义在include/linux/list.h中：

ass=&quot;prettyprint&quot;&gt;`/**
 * list_entry - get the struct for this entry
 * @ptr:    the &amp;amp;struct list_head pointer.
 * @type:   the type of the struct this is embedded in.
 * @member: the name of the list_struct within the struct.
 */
#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)`

container_of作用是通过结构体成员变量的地址和结构体成员变量名以及结构体类型获取该结构体变量的地址，被定义在include/linux/kernel.h中：

ass=&quot;prettyprint&quot;&gt;`/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:    the pointer to the member.
 * @type:   the type of the container struct this is embedded in.
 * @member: the name of the member within the struct.
 *
 */
#define container_of(ptr, type, member) ({          \
    const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);    \
    (type *)( (char *)__mptr - offsetof(type,member) );})`

const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr); 

typeof是c    语言的一个新拓展，有多重用法，主要用于得到其参数的类型，参数可以是表达式，函数，类型等，这里表示获取成员member的类型。 

这里定义的局部指针变量__mptr被赋值为member的地址。

(type _)( (char _)__mptr - offsetof(type,member) ); 

 (char *)__mptr：将__mptr转换为字节类型地址。 

offsetof(type, member)的作用是返回member在type中的偏移，其在include/linux/stddef.h中的定义如下：

ass=&quot;prettyprint&quot;&gt;`#ifdef __compiler_offsetof
#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &amp;amp;((TYPE *)0)-&amp;gt;MEMBER)
#endif
</code></pre><p>用实际的结构体成员变量的地址减去成员变量在结构体中的偏移地址，自然就得到该结构体变量的起始地址，最终得到(type*)类型的指针。</p>
<pre><code>    作者：WEINILUO 发表于2016/8/3 14:49:58 [原文链接](http://blog.csdn.net/weiniluo/article/details/52103145)


阅读：114 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52103145#comments)
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
    <article id="post-原-SSH端口转发与内网穿透" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/03/原-SSH端口转发与内网穿透/" class="article-date">
      <time datetime="2016-08-03T17:54:33.000Z" itemprop="datePublished">2016-08-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/03/原-SSH端口转发与内网穿透/">[原]SSH端口转发与内网穿透</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>1.内网系统配置：</p>
<pre><code>localhost$sudo ssh -R 0.0.0.0:port_vps:127.0.0.1:port_local username@vps_ip -p vps_ssh_port
port_vps:vps端的转发端口
port_local：本地ssh登录端口
vps_ssh_port：vps的ssh登录端口
`&lt;/pre&gt;

2.vps端配置

&lt;pre class=&quot;prettyprint&quot;&gt;`vps_host$vi /etc/ssh/ssh_config
+  GatewayPorts yes
vps_host$service ssh restart
</code></pre><p>3.帮助 </p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p>
<pre><code>&lt;div&gt;
    作者：WEINILUO 发表于2016/8/3 13:54:33 [原文链接](http://blog.csdn.net/weiniluo/article/details/51946721)
&lt;/div&gt;
&lt;div&gt;
阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51946721#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
            var yiliaConfig = {
            fancybox: true,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
            }
        </script>
        

  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 feison
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
            </div>
        </div>
        <div class="visit">
            <span id="busuanzi_container_site_pv" style='display:none'>
                <span id="site-visit" >本站到访数: 
                    <span id="busuanzi_value_site_uv"></span>
                </span>
            </span>
            <span id="busuanzi_container_page_pv" style='display:none'>
                <span id="page-visit">, 本页阅读量: 
                    <span id="busuanzi_value_page_pv"></span>
                </span>
            </span>
        </div>
    </div>
</footer>
    </div>
    
    <script>
        var yiliaConfig = {
            fancybox: false,
            mathjax: true,
            animate: true,
            isHome: true,
            isPost: false,
            isArchive: false,
            isTag: false,
            isCategory: false,
            open_in_new: false
        }
    </script>


<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>